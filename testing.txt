/*
module add()
this is module
endmodule
*/
module /* lol */ one (input I, output O);
  assign O = I;
endmodule //ignoeaf
// this is a comment
module two (input I, output O); // this is also a comment
  assign O = I;
endmodule

module top (input I, output O);
  wire W;
  one inst1 (.I(I), .O(W));
  two inst2 (.I(W), .O(O));
endmodule
module serializer(
  input clk,
  input load,
  input reg [7:0] in_value,
  output reg o_bit  )    ;
  reg[7:0] r1;
  always #10 clk =~clk;
  dalways ddadaev ;
  always @(posedge clk)
    begin
      if(load==1)
        begin
          r1 <= in_value;
        end
      else
        begin
          o_bit <= r1[7];
          r1 = r1 <<1;
        end
    end
endmodule
module shifter (
  input clk,
  input load,
  input right,
  input left,
  input [4:0] in_value,
  output reg[4:0] value);
  reg [4:0]r1;
  input reg [7:0] not_inside_in_value;
  input            not_inside_clk;
  output not_inside_output;
  output [7:0] not_inside__output;
  output reg[3:0] not_inside_reg_output;
/* this is a comment
aedna ljc vjsa vj rsj;v c
jnfrsncv
module ajckj c
 cahbkc ole */
  always@(posedge clk)
    begin
      if(load==1)
        begin
          r1[4:0] <=in_value[4:0];
        end
      else if(right==1)
        begin
          r1 = r1 >> 1;
        end
      else if(left==1)
        begin
          r1 = r1 << 1;
        end
    end
    always @(posedge clk)
    begin
      if (doAdd0)
        result0 <= a0 + b0;
      else
        result0 <= a0 - b0;
    end
  assign value[4:0] = r1[4:0];
endmodule
module ADD_SUB (
  input            clk,
  input [7:0]      a0,
  input [7:0]      b0,
  // if this is 1, add; else subtract
  input            doAdd0,
  output reg [8:0] result0,
  output always2 lol
);
always #100 h=!d;

  always @(posedge clk)
    begin
      if (doAdd0)
        result0 <= a0 + b0;
      else
        result0 <= a0 - b0;
    end
endmodule
module taef()
code
endmodule
module wtf()
hi;
endmodule
module XYZ (en, data, all_zero, result, status);
  input        eEn;
  input  [3:0] data;
  output       all_zero;
  input reg [7:0] in_value;
  output [3:0] result;
  inout  [1:0] status;
always #100 h=!d;
<body>
endmodule
module GRG_always (input A, B, C, D, Clock, nReset, Load, Clk, Reset, Enable,
                   input [2:0] Data,
                   output logic A1, A2, Q,
				   output logic [1:0] F,
				   output logic [2:0] Count, DCount1, DCount2);

  logic [3:0] R;
     always #10 clk =~clk;
  always @(A , B , C , D) // Equiv. to @(*), @*, or @(A or B or C or D)
  begin
    R = {A, B, C, D};
    F = 0;

    for (int I = 0; I < 4; I = I + 1)
      if (R[I])
      begin
        F = I;
        break;
      end
  end
  always @ (a,b,d or e,now)
    begin
    code
    end

endmodule