module one (input I, output O);
  assign O = I;
endmodule
module two (input I, output O);
  assign O = I;
endmodule

module top (input I, output O);
  wire W;
  one inst1 (.I(I), .O(W));
  two inst2 (.I(W), .O(O));
endmodule
module serializer(
  input clk,
  input load,
  input reg [7:0] in_value,
  output reg o_bit  )    ;
  reg[7:0] r1;
  always @(posedge clk)
    begin
      if(load==1)
        begin
          r1 <= in_value;
        end
      else
        begin
          o_bit <= r1[7];
          r1 = r1 <<1;
        end
    end
endmodule
module shifter (
  input clk,
  input load,
  input right,
  input left,
  input [4:0] in_value,
  output reg[4:0] value);
  reg [4:0]r1;
  input reg [7:0] not_inside_in_value;
  input            not_inside_clk;
  output not_inside_output;
  output [7:0] not_inside__output;
  output reg[3:0] not_inside_reg_output;

  always@(posedge clk)
    begin
      if(load==1)
        begin
          r1[4:0] <=in_value[4:0];
        end
      else if(right==1)
        begin
          r1 = r1 >> 1;
        end
      else if(left==1)
        begin
          r1 = r1 << 1;
        end
    end
    always @(posedge clk)
    begin
      if (doAdd0)
        result0 <= a0 + b0;
      else
        result0 <= a0 - b0;
    end
  assign value[4:0] = r1[4:0];
endmodule
module ADD_SUB (
  input            clk,
  input [7:0]      a0,
  input [7:0]      b0,
  // if this is 1, add; else subtract
  input            doAdd0,
  output reg [8:0] result0,
  output always2 lol
);

  always @(posedge clk)
    begin
      if (doAdd0)
        result0 <= a0 + b0;
      else
        result0 <= a0 - b0;
    end
endmodule


module wtf()
hi;
endmodule
module XYZ (en, data, all_zero, result, status);
  input        eEn;
  input  [3:0] data;
  output       all_zero;
  input reg [7:0] in_value;
  output [3:0] result;
  inout  [1:0] status;

<body>
endmodule